package hooks

import (
	"bufio"
	"io"
	"os"
	"path/filepath"
	"strings"

	"github.com/cszatma/go-fish/util"
	"github.com/pkg/errors"
)

var hooks = map[string]bool{
	"applypatch-msg":     true,
	"pre-applypatch":     true,
	"post-applypatch":    true,
	"pre-commit":         true,
	"prepare-commit-msg": true,
	"commit-msg":         true,
	"post-commit":        true,
	"pre-rebase":         true,
	"post-checkout":      true,
	"post-merge":         true,
	"pre-push":           true,
	"pre-receive":        true,
	"update":             true,
	"post-receive":       true,
	"post-update":        true,
	"push-to-checkout":   true,
	"pre-auto-gc":        true,
	"post-rewrite":       true,
	"sendemail-validate": true,
}

func IsValidHook(hook string) bool {
	_, ok := hooks[hook]
	return ok
}

func isGoFishHook(r io.Reader) bool {
	// Look for `id` in file to see if it was generated by go-fish
	s := bufio.NewScanner(r)
	for s.Scan() {
		if strings.Contains(s.Text(), goFishID) {
			return true
		}
	}

	return false
}

func createHook(name, path, script string, force bool) error {
	if util.FileOrDirExists(path) {
		f, err := os.Open(path)
		if err != nil {
			return errors.Wrapf(err, "Failed to open hook file %s", path)
		}
		defer f.Close()

		if !(isGoFishHook(f) || force) {
			util.VerbosePrintf("Skipping existing user hook: %s\n", name)
			return nil
		}

		util.VerbosePrintf("Updating existing hook: %s\n", name)
	} else {
		util.VerbosePrintf("Creating hook: %s\n", name)
	}

	f, err := os.OpenFile(path, os.O_RDWR|os.O_CREATE|os.O_TRUNC, 0755)
	if err != nil {
		return errors.Wrapf(err, "Failed to open file %s", path)
	}
	defer f.Close()

	_, err = f.WriteString(script)
	f.Sync()
	return errors.Wrapf(err, "Failed to write hook at %s", path)
}

func removeHook(name, path string, force bool) error {
	if !util.FileOrDirExists(path) {
		util.VerbosePrintf("Hook does not exists, skipping: %s\n", name)
		return nil
	}

	f, err := os.Open(path)
	if err != nil {
		return errors.Wrapf(err, "Failed to open hook file %s", path)
	}
	defer f.Close()

	if !(isGoFishHook(f) || force) {
		util.VerbosePrintf("Skipping user hook: %s\n", name)
		return nil
	}

	util.VerbosePrintf("Removing hook: %s\n", name)
	err = os.Remove(path)
	return errors.Wrapf(err, "Failed to remove hook at %s", path)
}

// CreateHooks creates each git hook.
func CreateHooks(path, script string, force bool) error {
	for hook := range hooks {
		hookPath := filepath.Join(path, hook)
		err := createHook(hook, hookPath, script, force)
		if err != nil {
			return errors.Wrapf(err, "Failed to create hook %s", hook)
		}
	}

	return nil
}

// RemoveHooks removes each git hook.
func RemoveHooks(path string, force bool) error {
	for hook := range hooks {
		hookPath := filepath.Join(path, hook)
		err := removeHook(hook, hookPath, force)
		if err != nil {
			return errors.Wrapf(err, "Failed to remove hook %s", hook)
		}
	}

	return nil
}
